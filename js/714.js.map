{"version":3,"file":"714.js","mappings":"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","sources":["webpack://sakurairo-scripts/./node_modules/_prismjs@1.26.0@prismjs/plugins/command-line/prism-command-line.js"],"sourcesContent":["(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tvar CLASS_PATTERN = /(?:^|\\s)command-line(?:\\s|$)/;\n\tvar PROMPT_CLASS = 'command-line-prompt';\n\n\t/** @type {(str: string, prefix: string) => boolean} */\n\tvar startsWith = ''.startsWith\n\t\t? function (s, p) { return s.startsWith(p); }\n\t\t: function (s, p) { return s.indexOf(p) === 0; };\n\n\t/**\n\t * Repeats the given string some number of times.\n\t *\n\t * This is just a polyfill for `String.prototype.repeat`.\n\t *\n\t * @param {string} str\n\t * @param {number} times\n\t * @returns {string}\n\t */\n\tfunction repeat(str, times) {\n\t\tvar s = '';\n\t\tfor (var i = 0; i < times; i++) {\n\t\t\ts += str;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Returns whether the given hook environment has a command line info object.\n\t *\n\t * @param {any} env\n\t * @returns {boolean}\n\t */\n\tfunction hasCommandLineInfo(env) {\n\t\tvar vars = env.vars = env.vars || {};\n\t\treturn 'command-line' in vars;\n\t}\n\t/**\n\t * Returns the command line info object from the given hook environment.\n\t *\n\t * @param {any} env\n\t * @returns {CommandLineInfo}\n\t *\n\t * @typedef CommandLineInfo\n\t * @property {boolean} [complete]\n\t * @property {number} [numberOfLines]\n\t * @property {string[]} [outputLines]\n\t */\n\tfunction getCommandLineInfo(env) {\n\t\tvar vars = env.vars = env.vars || {};\n\t\treturn vars['command-line'] = vars['command-line'] || {};\n\t}\n\n\n\tPrism.hooks.add('before-highlight', function (env) {\n\t\tvar commandLine = getCommandLineInfo(env);\n\n\t\tif (commandLine.complete || !env.code) {\n\t\t\tcommandLine.complete = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// Works only for <code> wrapped inside <pre> (not inline).\n\t\tvar pre = env.element.parentElement;\n\t\tif (!pre || !/pre/i.test(pre.nodeName) || // Abort only if neither the <pre> nor the <code> have the class\n\t\t\t(!CLASS_PATTERN.test(pre.className) && !CLASS_PATTERN.test(env.element.className))) {\n\t\t\tcommandLine.complete = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// The element might be highlighted multiple times, so we just remove the previous prompt\n\t\tvar existingPrompt = env.element.querySelector('.' + PROMPT_CLASS);\n\t\tif (existingPrompt) {\n\t\t\texistingPrompt.remove();\n\t\t}\n\n\t\tvar codeLines = env.code.split('\\n');\n\t\tcommandLine.numberOfLines = codeLines.length;\n\t\t/** @type {string[]} */\n\t\tvar outputLines = commandLine.outputLines = [];\n\n\t\tvar outputSections = pre.getAttribute('data-output');\n\t\tvar outputFilter = pre.getAttribute('data-filter-output');\n\t\tif (outputSections !== null) { // The user specified the output lines. -- cwells\n\t\t\toutputSections.split(',').forEach(function (section) {\n\t\t\t\tvar range = section.split('-');\n\t\t\t\tvar outputStart = parseInt(range[0], 10);\n\t\t\t\tvar outputEnd = range.length === 2 ? parseInt(range[1], 10) : outputStart;\n\n\t\t\t\tif (!isNaN(outputStart) && !isNaN(outputEnd)) {\n\t\t\t\t\tif (outputStart < 1) {\n\t\t\t\t\t\toutputStart = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (outputEnd > codeLines.length) {\n\t\t\t\t\t\toutputEnd = codeLines.length;\n\t\t\t\t\t}\n\t\t\t\t\t// Convert start and end to 0-based to simplify the arrays. -- cwells\n\t\t\t\t\toutputStart--;\n\t\t\t\t\toutputEnd--;\n\t\t\t\t\t// Save the output line in an array and clear it in the code so it's not highlighted. -- cwells\n\t\t\t\t\tfor (var j = outputStart; j <= outputEnd; j++) {\n\t\t\t\t\t\toutputLines[j] = codeLines[j];\n\t\t\t\t\t\tcodeLines[j] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (outputFilter) { // Treat lines beginning with this string as output. -- cwells\n\t\t\tfor (var i = 0; i < codeLines.length; i++) {\n\t\t\t\tif (startsWith(codeLines[i], outputFilter)) { // This line is output. -- cwells\n\t\t\t\t\toutputLines[i] = codeLines[i].slice(outputFilter.length);\n\t\t\t\t\tcodeLines[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tenv.code = codeLines.join('\\n');\n\t});\n\n\tPrism.hooks.add('before-insert', function (env) {\n\t\tvar commandLine = getCommandLineInfo(env);\n\n\t\tif (commandLine.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Reinsert the output lines into the highlighted code. -- cwells\n\t\tvar codeLines = env.highlightedCode.split('\\n');\n\t\tvar outputLines = commandLine.outputLines || [];\n\t\tfor (var i = 0, l = outputLines.length; i < l; i++) {\n\t\t\tif (outputLines.hasOwnProperty(i)) {\n\t\t\t\tcodeLines[i] = outputLines[i];\n\t\t\t}\n\t\t}\n\t\tenv.highlightedCode = codeLines.join('\\n');\n\t});\n\n\tPrism.hooks.add('complete', function (env) {\n\t\tif (!hasCommandLineInfo(env)) {\n\t\t\t// the previous hooks never ran\n\t\t\treturn;\n\t\t}\n\n\t\tvar commandLine = getCommandLineInfo(env);\n\n\t\tif (commandLine.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar pre = env.element.parentElement;\n\t\tif (CLASS_PATTERN.test(env.element.className)) { // Remove the class \"command-line\" from the <code>\n\t\t\tenv.element.className = env.element.className.replace(CLASS_PATTERN, ' ');\n\t\t}\n\t\tif (!CLASS_PATTERN.test(pre.className)) { // Add the class \"command-line\" to the <pre>\n\t\t\tpre.className += ' command-line';\n\t\t}\n\n\t\tfunction getAttribute(key, defaultValue) {\n\t\t\treturn (pre.getAttribute(key) || defaultValue).replace(/\"/g, '&quot');\n\t\t}\n\n\t\t// Create the \"rows\" that will become the command-line prompts. -- cwells\n\t\tvar promptLines;\n\t\tvar rowCount = commandLine.numberOfLines || 0;\n\t\tvar promptText = getAttribute('data-prompt', '');\n\t\tif (promptText !== '') {\n\t\t\tpromptLines = repeat('<span data-prompt=\"' + promptText + '\"></span>', rowCount);\n\t\t} else {\n\t\t\tvar user = getAttribute('data-user', 'user');\n\t\t\tvar host = getAttribute('data-host', 'localhost');\n\t\t\tpromptLines = repeat('<span data-user=\"' + user + '\" data-host=\"' + host + '\"></span>', rowCount);\n\t\t}\n\n\t\t// Create the wrapper element. -- cwells\n\t\tvar prompt = document.createElement('span');\n\t\tprompt.className = PROMPT_CLASS;\n\t\tprompt.innerHTML = promptLines;\n\n\t\t// Remove the prompt from the output lines. -- cwells\n\t\tvar outputLines = commandLine.outputLines || [];\n\t\tfor (var i = 0, l = outputLines.length; i < l; i++) {\n\t\t\tif (outputLines.hasOwnProperty(i)) {\n\t\t\t\tvar node = prompt.children[i];\n\t\t\t\tnode.removeAttribute('data-user');\n\t\t\t\tnode.removeAttribute('data-host');\n\t\t\t\tnode.removeAttribute('data-prompt');\n\t\t\t}\n\t\t}\n\n\t\tenv.element.insertBefore(prompt, env.element.firstChild);\n\t\tcommandLine.complete = true;\n\t});\n\n}());\n"],"names":["Prism","document","CLASS_PATTERN","PROMPT_CLASS","startsWith","s","p","indexOf","hooks","add","env","commandLine","getCommandLineInfo","complete","code","pre","element","parentElement","test","nodeName","className","existingPrompt","querySelector","remove","codeLines","split","numberOfLines","length","outputLines","outputSections","getAttribute","outputFilter","forEach","section","range","outputStart","parseInt","outputEnd","isNaN","j","i","slice","join","highlightedCode","l","hasOwnProperty","vars","hasCommandLineInfo","promptLines","replace","rowCount","promptText","repeat","prompt","createElement","innerHTML","node","children","removeAttribute","insertBefore","firstChild","key","defaultValue","str","times"],"sourceRoot":""}